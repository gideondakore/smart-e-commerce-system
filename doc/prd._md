# Product Requirements Document (PRD)

## Project Title
Smart E-Commerce System (Database Fundamentals)

## Version
1.0

## Date
January 05, 2026

## Authors/Contributors
- Lab Developers: IntelliJ IDEA Community Edition (based on technology stack)
- Technology Focus: JavaFX, JDBC, MySQL/PostgreSQL

## 1. Introduction

### 1.1 Purpose
This Product Requirements Document (PRD) outlines the requirements for developing the data layer of a Smart E-Commerce System. The system focuses on designing a relational database schema for e-commerce operations, implementing SQL-based persistence, and integrating it with a JavaFX application for user interactions. It incorporates data structures and algorithms for optimization, such as indexing, hashing, searching, sorting, and caching. The goal is to create a scalable, efficient backend that supports real-world e-commerce features like product management, order processing, and performance reporting, while exploring NoSQL alternatives for unstructured data.

### 1.2 Scope
- **In Scope**: 
  - Database design: Conceptual, logical, and physical models normalized to 3NF.
  - SQL implementation: Tables, constraints, indexes, foreign keys, and sample data.
  - JavaFX integration: CRUD operations, searching, sorting, and reporting via JDBC.
  - Optimization: Indexing, hashing, caching, searching/sorting algorithms, and performance measurement.
  - NoSQL exploration: Design for unstructured data like reviews or logs.
  - Documentation: ERDs, performance reports, README, and testing evidence.
- **Out of Scope**:
  - Full e-commerce frontend (e.g., web/mobile UI beyond basic JavaFX).
  - Payment processing or external integrations (e.g., APIs for shipping).
  - Advanced security features (e.g., encryption, authentication beyond basic).
  - Deployment to production environments.
  - Machine learning or AI enhancements.

### 1.3 Target Audience
- Developers/Students learning database fundamentals and Java integration.
- End-users: Simulated administrators (inventory management) and customers (product browsing/searching).

### 1.4 Assumptions and Dependencies
- Java environment with JavaFX and JDBC drivers.
- Relational DBMS: MySQL or PostgreSQL installed and accessible.
- No external libraries beyond standard Java APIs and JDBC.
- System runs locally for development and testing.
- Sample data is small-scale for performance testing.

## 2. Objectives

By completing this system, users/developers will be able to:
- Design and normalize relational database schemas for e-commerce domains.
- Implement CRUD operations and complex queries using SQL and JDBC.
- Apply indexing, hashing, searching, and sorting to optimize data access.
- Integrate database operations with a JavaFX UI for interactive management.
- Compare relational and NoSQL designs for handling unstructured data.
- Measure and document performance improvements through optimizations.
- Ensure data integrity, efficiency, and maintainability in the application.

## 3. System Overview

### 3.1 High-Level Architecture
- **Data Layer**: Relational database (MySQL/PostgreSQL) with normalized schema; optional NoSQL for unstructured data.
- **Application Layer**: JavaFX for UI, JDBC for database connectivity, in-memory structures for caching/sorting.
- **Optimization Layer**: Indexes, hashing/caching, algorithms for searching/sorting.
- **Reporting**: Performance metrics and query optimizations documented.

### 3.2 Key Components
- **Entities**: Users, Products, Categories, Orders, OrderItems, Reviews, Inventory.
- **Services/DAOs**: ProductService, OrderService, DAO classes for CRUD.
- **UI Components**: JavaFX scenes for product listing, search, admin panel.
- **Utils**: OptimizationUtils (for caching, sorting), ValidationUtils.
- **Docs**: ERDs, SQL scripts, performance report, README.md.

### 3.3 Data Flow
- Design schema and create database via SQL scripts.
- Load data into JavaFX app using JDBC queries.
- Perform CRUD, search, sort operations with optimizations.
- Cache frequent data in-memory; invalidate on updates.
- Generate reports comparing query times.
- Explore NoSQL for reviews/logs export.

## 4. Features

### 4.1 Feature 1: Database Design and Modeling
- Create conceptual ERD, logical model (attributes/keys), physical model (SQL types/constraints).
- Normalize to 3NF; define indexes on frequent columns (e.g., product name, category ID).
- Enforce referential integrity with foreign keys.

### 4.2 Feature 2: Data Access and CRUD Operations
- Implement add/update/delete for products/categories via JavaFX.
- View product listings with pagination/filters.
- Use parameterized JDBC queries for security and efficiency.

### 4.3 Feature 3: Searching, Sorting, and Optimization
- Case-insensitive product search by name/category using indexing/hashing.
- In-memory caching (e.g., Maps/Lists) for frequent data.
- Sorting algorithms for results; cache invalidation on updates.

### 4.4 Feature 4: Performance and Query Optimization
- Measure query times before/after indexing/caching.
- Generate reports showing efficiency gains.
- Explore NoSQL (e.g., document model) for reviews/logs with justification.

### 4.5 Feature 5: Reporting and Documentation
- Include ERD diagrams, SQL scripts, sample data.
- README with setup, dependencies, execution steps.
- Testing evidence (screenshots of queries/UI).

## 5. User Stories

### Epic 1: Database Design and Modeling
- US-1.1: As a database designer, I want to create conceptual, logical, and physical models so that the data structure is clear and efficient.
- US-1.2: As a database administrator, I want to define indexes and relationships so that queries run efficiently and data integrity is maintained.

### Epic 2: Data Access and CRUD Operations
- US-2.1: As an administrator, I want to add, update, and delete product and category data from the JavaFX interface so that I can manage inventory.
- US-2.2: As a user, I want to view products and their details from the application so that I can browse and make purchase decisions.

### Epic 3: Searching, Sorting, and Optimization
- US-3.1: As a customer, I want to search for products quickly by name or category so that I can find items efficiently.
- US-3.2: As a developer, I want to implement in-memory caching and sorting so that frequently accessed or sorted data is retrieved faster.

### Epic 4: Performance and Query Optimization
- US-4.1: As an analyst, I want to generate performance reports comparing pre- and post-optimization so that I can measure system efficiency.
- US-4.2: As a developer, I want to explore storing customer feedback or logs in a NoSQL format so that unstructured data can be efficiently handled.

### Epic 5: Reporting and Documentation
- US-5.1: As a project contributor, I want to produce documentation and reports so that the project can be reviewed, reused, or extended.

## 6. Functional Requirements

- **Database Schema**: Normalized to 3NF; includes entities like Users, Products, etc.; indexes on high-frequency columns.
- **CRUD Operations**: Functional via JavaFX; input validation; prevent SQL injection with parameterized queries.
- **Search/Sort**: Case-insensitive search; sorting by algorithms; caching for speed.
- **Optimization**: Demonstrate performance gains; optional NoSQL model.
- **Reporting**: Query time comparisons; ERDs and scripts.
- **Error Handling**: Feedback messages; handle JDBC exceptions.

## 7. Non-Functional Requirements

- **Performance**: Measurable improvements in query times; efficient for small datasets.
- **Usability**: Intuitive JavaFX UI with pagination and filters.
- **Reliability**: Data integrity via constraints; consistent caching.
- **Maintainability**: Layered architecture (Controller-Service-DAO); documented code.
- **Compatibility**: Java with JavaFX/JDBC; MySQL/PostgreSQL.
- **Security**: Parameterized queries; basic input validation.

## 8. Implementation Phases

### Phase 1: Database Design
- Create ERD and models; normalize schema.
- Write SQL scripts for tables, indexes, constraints.

### Phase 2: JDBC Integration
- Set up DAO classes for CRUD.
- Implement parameterized queries.

### Phase 3: JavaFX UI
- Build interfaces for product management and browsing.
- Integrate search, sort, and pagination.

### Phase 4: Optimization
- Add caching, hashing, sorting algorithms.
- Measure and report performance.

### Phase 5: NoSQL and Documentation
- Design NoSQL model (optional).
- Compile reports, README, and testing evidence.

## 9. Testing

- **Test Scenario 1**: Database Design – Validate schema creation, normalization, and indexes via SQL execution.
- **Test Scenario 2**: CRUD Operations – Add/update/delete products; verify data persistence and validation.
- **Test Scenario 3**: Search/Sort – Test case-insensitive search; measure times with/without indexing.
- **Test Scenario 4**: Optimization – Compare query speeds; validate cache invalidation.
- **Test Scenario 5**: Reporting – Generate performance report; ensure NoSQL justification is logical.
- **Additional Tests**: UI usability; error handling; referential integrity.

## 10. Grading Rubric

| # | Criteria                  | Points | Excellent (90-100%)                          | Good (75-89%)                          | Satisfactory (60-74%)                  |
|---|---------------------------|--------|----------------------------------------------|----------------------------------------|----------------------------------------|
| 1 | Database Design           | 25     | Complete models, 3NF, well-documented ERDs  | Partial models or minor normalization issues | Incomplete or unnormalized schema     |
| 2 | SQL Implementation        | 20     | Correct schema, constraints, indexes, complex queries | Partial support for queries            | Basic tables only                      |
| 3 | JavaFX + JDBC Integration | 20     | Functional CRUD, safe handling, usable UI   | Minor bugs in operations               | Unstable integration                   |
| 4 | DSA Application           | 15     | Clear caching/sorting with justification    | Partial optimization                   | Minimal DSA use                        |
| 5 | Performance Optimization | 10     | Demonstrated gains through analysis         | Basic measurements                     | No measurable improvements             |
| 6 | Documentation & Code Quality | 10  | Complete README, organized code             | Partial coverage                       | Minimal documentation                  |
| 7 | Total                     | 100    |                                              |                                        |                                        |

## 11. Submission Requirements
- Public GitHub Repository with Source Code (/src).
- SQL Scripts and Data (/db).
- JavaFX Application Executable.
- Performance Report and NoSQL Design (/docs).
- README documenting setup, dependencies, SQL execution, and usage.
- Testing Evidence (screenshots).
- At least one commit per phase.
- Submission Link: Insert Google Form or LMS link here.

## 12. Appendix

### 12.1 Project Structure
```
smart-ecommerce-system/
├── src/
│   ├── Main.java
│   ├── models/
│   │   ├── User.java
│   │   ├── Product.java
│   │   ├── Category.java
│   │   ├── Order.java
│   │   ├── OrderItem.java
│   │   ├── Review.java
│   │   └── Inventory.java
│   ├── services/
│   │   ├── ProductService.java
│   │   ├── OrderService.java
│   │   └── Dao/
│   │       └── ProductDao.java  # JDBC implementations
│   └── utils/
│       ├── OptimizationUtils.java  # Caching, sorting
│       └── ValidationUtils.java
├── db/
│   ├── schema.sql
│   └── sample-data.sql
├── docs/
│   ├── erd.png
│   ├── performance-report.md
│   └── nosql-design.md
└── README.md
```

### 12.2 Expected User Workflows
- **Workflow 1: Database Setup** – Run SQL scripts → verify tables/indexes → insert sample data → confirm integrity.
- **Workflow 2: Product Management** – Launch JavaFX → admin adds product → validate inputs → search/sort results → update/delete.
- **Workflow 3: Optimization Testing** – Run queries without index/cache → add optimizations → compare times → document gains.
- **Workflow 4: NoSQL Exploration** – Design model for reviews → justify vs. relational → optional import/export data.

### 12.3 Risks and Mitigations
- Risk: Data inconsistency – Mitigation: Enforce constraints and foreign keys.
- Risk: Performance bottlenecks – Mitigation: Use indexes and caching; test with timers.
- Risk: JDBC errors – Mitigation: Handle exceptions; use try-with-resources.

This PRD serves as a comprehensive guide for developing the Smart E-Commerce System. For any clarifications, refer to the original project document.